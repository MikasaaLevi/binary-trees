Binary tree Iterative traversals:

Preorder:- Pre-order traversal is to visit the root first. Then traverse the left subtree. Finally, traverse the right subtree.

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]

Explanation:- 

Since preorder is root first then the left and right child respectively, we use a stack to push the root in first pop it and then use the stack to 
first store its right child and then its left child, since stack is LIFO, it will pop out the left child followed by the right child, the required 
fashion. Continue this while all the nodes have been traversed, i.e, the stack becomes empty.

code:-

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> preorder=new ArrayList<Integer>();
        Stack<TreeNode> nodes=new Stack<TreeNode>();
        if(root==null)
            return preorder;
        nodes.push(root);
        while(!nodes.isEmpty())
        {
            TreeNode temp=nodes.peek();
            nodes.pop();
            preorder.add(temp.val);
            if(temp.right!=null)
            nodes.push(temp.right);
            if(temp.left!=null)
            nodes.push(temp.left);
        }
        return preorder;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
PostOrder:-Post-order traversal is to traverse the left subtree first. Then traverse the right subtree. Finally, visit the root.

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]

Explanation:-

The idea is to travel as left as possible first and keep pushing them into the stack so that we can keep track of the subtrees of those left-child nodes 
of the root. After we reach the leftmost node i.e. the left child of the then top of the stack is null, we check if its a leaf node i.e,if its right child 
is present, if it's present then we just push the right child onto the stack and continue the process for that right-child(subtree), otherwise, we just
print it and pop it from the stack and check whether it was the right child , in that case the subtree's both left and right child are visited so its time
to pop the root out of the stack and we continue to pop till the popped root is the right child of the top of the stack(parent node).

Algorithm:-

iterativePostorder(node)
  s ← empty stack
  lastNodeVisited ← null
  while (not s.isEmpty() or node ≠ null)
    if (node ≠ null)
      s.push(node)
      node ← node.left
    else
      peekNode ← s.peek()
      // if right child exists and traversing node
      // from left child, then move right
      if (peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right)
        node ← peekNode.right
      else
        visit(peekNode)
        lastNodeVisited ← s.pop()

code:-

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> postorder=new ArrayList<>();
        Stack<TreeNode> st=new Stack<TreeNode>();
        TreeNode curr=root;
        while(curr!=null || !st.isEmpty())
        {
            if(curr!=null)
            {
                st.push(curr);
                curr=curr.left;
            }
            else
            {
                TreeNode temp=st.peek().right;
                if(temp==null)
                {
                   while(!st.isEmpty()&& temp==st.peek().right)
                   {
                       temp=st.peek();
                       postorder.add(temp.val);
                       st.pop();
                   }
                }
                else
                {
                    curr=temp;
                }
            }
        }
        return postorder;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Inorder:- In-order traversal is to traverse the left subtree first. Then visit the root. Finally, traverse the right subtree.

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]

Explanation:-

1) Create an empty stack to S.
2) Initialize current node as root
3) Push the current node to S and set current = current->left until current is NULL
4) If current is NULL and stack is not empty then 
     a) Pop the top item from stack.
     b) Print the popped item, set current = popped_item->right 
     c) Go to step 3.
5) If current is NULL and stack is empty then we are done.

code:-

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        Stack<TreeNode> st=new Stack<TreeNode>();
        List<Integer> inorder=new ArrayList<>();
        if(root==null)
            return inorder;
        TreeNode curr=root;
        while(curr!=null || !st.isEmpty())
        {
            if(curr!=null)
            {
                st.push(curr);
                curr=curr.left;
            }
            else if(curr==null && !st.isEmpty())
            {
               TreeNode temp=st.peek();
               st.pop();
               inorder.add(temp.val);
               curr=temp.right;
            }
        }
        return inorder;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Note:-
While Preorder,post-order and inorder are Depth first approaches, Level order traversal is a breadth first approach.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Level order traversal:- 

Given binary tree [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7

answer:- [
  [3],
  [9,20],
  [15,7]
]

Explanation:-

We use BFS on tree, i.e, we visit the node itself first and then its neighbours, here left and right children. The size of each level varies depending 
on the number of nodes present in the stack and at each level children of those nodes are pushed in into the queue (FIFO order) as those nodes are
popped out.

code:-

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> levelNode=new LinkedList<TreeNode>();
        List<List<Integer>> nodes=new ArrayList<>();
        if(root==null)
            return nodes;
        levelNode.add(root);
        while(!levelNode.isEmpty())
        {
            int size=levelNode.size();
            List<Integer> currentLevel=new ArrayList<>();
            for(int i=0;i<size;i++)
            {
               TreeNode temp=levelNode.remove();
                currentLevel.add(temp.val);
                if(temp.left!=null)
                    levelNode.add(temp.left);
                if(temp.right!=null)
                    levelNode.add(temp.right);
            }
           nodes.add(currentLevel); 
        }
        return nodes;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Morris traversal:

This is used for traversal of trees without any extra space (i.e without stack or recursion).

What is a threaded binary tree?

A binary tree can be threaded by making the right child that would poin to null ordinarily point to the inorder successor and the left child that would
normally point to nul point to the inorder predecessor of the node.

Morris Inorder traversal:-

Explanation:-

Algorithm:-

Code:-


Morris Preorder traversal:-

Explanation:-

Algorithm:-

Code:-